# vi: set ts=8
properties:
32 bit instructions
16 registers
3 address

r0-r15 - 32bit

SP = r14
LR = r15

instruction forms
33222222222211111111110000000000
10987654321098765432109876543210
--------------------------------
00ppddddppppaaaaiiiiiiiiiiiiiiii
01ppddddppppaaaabbbbxxxxxxxxxxxx
10ppddddppiiiiiiiiiiiiiiiiiiiiii
11xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

all immediates are sign extended

			00 -- immediate version
			01 -- register,register

	alu ops
add			0?  00 d<4> 0000 a<4> b<4>,imm<16>	a + b
sub			0?  00 d<4> 0001 a<4> b<4>,imm<16>	a - b
rsb			0?  00 d<4> 0010 a<4> b<4>,imm<16>	b - a
and			0?  00 d<4> 0011 a<4> b<4>,imm<16>	a & b
or			0?  00 d<4> 0100 a<4> b<4>,imm<16>	a | b
xor			0?  00 d<4> 0101 a<4> b<4>,imm<16>	a ^ b
lsl			0?  00 d<4> 0110 a<4> b<4>,imm<16>	a << b
lsr			0?  00 d<4> 0111 a<4> b<4>,imm<16>	a >> b
asr			0?  00 d<4> 1000 a<4> b<4>,imm<16>	a >>> b (sign extend)
mov			0?  00 d<4> 1001 ign  b<4>,imm<16>	b
mvb			0?  00 d<4> 1010 ign  b<4>,imm<16>	b & 0xffff
mvt			0?  00 d<4> 1011 a<4> b<4>,imm<16>	a | (b << 16)

slt			0?  00 d<4> 1100 a<4> b<4>,imm<16>	a < b
slte			0?  00 d<4> 1101 a<4> b<4>,imm<16>	a <= b
seq			0?  00 d<4> 1110 a<4> b<4>,imm<16>	a == b

unused			0?  00 d<4> 1111 a<4> b<4>,imm<16>

	load/store
ldr			0?  01 d<4> 0000 a<4> b<4>,imm<16>	ldr Rd, [Ra + Rb]
str	        	0?  10 d<4> 0000 a<b> b<4>,imm<16>	str Rd, [Ra + Rb]

	unused
			0?  11 xxxx xxxxxxxxxxxxxxxxxxxxx

	branch
b<l><z,nz>		10  0L d<4> cn imm<22>
	l = save old PC+1 into link register
	c = do a zero/notzero test against Rd
	n = if c, test for zero or !zero in register Rd

	imm<22> is shifted left 2, sign extended

b<l><z,nz>	r	10  1L d<4> cn xx a<4> xxxxxxxxxxxx
	-same as above, but register target
	-bottom 2 bits of reg target ignored

	unused
			11  xxxxxxx xxxxxxxxxxxxxxxxxxxxx

pseudo instructions:
mvn	a, b	-	rsb a, b, #0
not	a, b	-	xor a, b, #0
li  a, #imm -   mvb a, #(imm & 0xffff); mvt a, #(imm >> 16)

common algorithms:

a < b and branch
clt     cr, a, b
bz      cr

a > b and branch
slte    cr, a, b
bz      cr

a <= b and branch
clte    cr, a, b
bz      cr

a >= b and branch
slt     cr, a, b
bz      cr

a == b and branch
ceq     cr, a, b
bz      cr

a != b and branch
seq     cr, a, b
bz      cr

test for negative
clt     a, #0

64bit add   c = a + b
add     cl, al, bl
slt     cr, cl, al
add     ch, ah, bh
add     ch, ch, cr


