isa1

properties:
16 bit instructions
8 registers
3 address ops
no condition bits

load/store
addressing modes:
    <reg>,[<reg>]
    <reg>,[<reg>,#imm]
    <reg>,[<reg>,#imm]+		# only on store
    <reg>,[<reg>],#imm]+	# only on load
    <reg>,[PC,#imm]         # only on load

ldr
str

load immediate
li      <reg>,#immediate    # 10 bits of immediate, sign extended

3 address data processing:
two forms    <reg>,<reg>,<reg>    -     <reg>,<reg>,#immediate (3 bits)
add   
sub
and
or
xor
lsl
lsr
rol
ror
asr

comparison
slt         set 1 on <      ==  cgte    set 0 on >=
clt         set 0 on <      ==  sgte    set 1 on >=
slte        set 1 on <=     ==  cgt     set 0 on >
clte        set 0 on <=     ==  sgt     set 1 on >
seq         set 1 on ==
ceq         set 0 on ==

conditional branch
bz  <reg>, <offset>

branch
b   <reg>
bl  <reg>
b   <offset>
bl  <offset>        # modifies r7

system instructions
mov to/from control register, 8 bits of control register
swi?

LR = r7
SP = r6

            15-12      11      10      9       8       7       6       5       4       3       2       1       0
add         0000       0       0       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd  # R == 1 ? Rb : 3 bits of immediate
sub         0000       0       1       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd
and         0000       1       0       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd
or          0000       1       1       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd
xor         0001       0       0       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd
lsl         0001       0       1       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd
lsr         0001       1       0       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd
asr         0001       1       1       R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd

slt/clt     0010       0       ZO      R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd  # set 0 or 1 on Ra < Rb
slte/clte   0010       1       ZO      R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd  # set 0 or 1 on Ra <= Rb
seq/ceq     0011       0       ZO      R       Rb/imm  Rb/imm  Rb/imm  Ra      Ra      Ra      Rd      Rd      Rd  # set 0 or 1 on Ra == Rb

unused      0011       1       X       X       X       X       X       X       X       X       X       X       X

ldr         0100       imm     imm     imm     imm     imm     0       Ra      Ra      Ra      Rd      Rd      Rd  # <reg>,[<reg>,#imm5]
ldr         0100       imm     imm     imm     imm     imm     1       Ra      Ra      Ra      Rd      Rd      Rd  # <reg>,[<reg>],#imm5+   - post update the base register
ldr         0101       imm     imm     imm     imm     imm     imm     imm     imm     imm     Rd      Rd      Rd  # <reg>,[PC,#imm9]       - 9 bits of PC offset

str         0110       imm     imm     imm     imm     imm     0       Ra      Ra      Ra      Rd      Rd      Rd  # <reg>,[<reg>,#imm5]
str         0110       imm     imm     imm     imm     imm     1       Ra      Ra      Ra      Rd      Rd      Rd  # <reg>,[<reg>,#imm5]+   - update the base register
li          0111       imm     imm     imm     imm     imm     imm     imm     imm     imm     Rd      Rd      Rd  # 9 bit immediate, sign extend

bz          1000       off     off     off     off     off     off     off     off     off     Rd      Rd      Rd  # branch if register zero, 9 bits of branch
bnz         1001       off     off     off     off     off     off     off     off     off     Rd      Rd      Rd  # branch if register not zero, 9 bits of branch
b           1010       off     off     off     off     off     off     off     off     off     off     off     off # branch 12 bits of branch
b(l) r      1011       L       X       X       X       X       X       X       X       X       Rd      Rd      Rd  # branch to Rd, if L set LR <= PC + 2

bl (1st)    1100       off     off     off     off     off     off     off     off     off     off     off     off # LR <= signextend(offset12 << 12)
bl          1101       off     off     off     off     off     off     off     off     off     off     off     off # pc <= LR | offset12, LR <= PC + 2

expansion:
            1110       X       X       X       X       X       X       X       X       X       X       X       X
            1111       X       X       X       X       X       X       X       X       X       X       X       X

pseudo instructions:
mov		a, b			- 		add		a, b, #0
push	a				- 		str		a, [sp, #-4]+
pop		a				-		ldr		a, [sp], #4+

common algorithms:

a < b and branch
clt     t, a, b
bz      t

a > b and branch
slte    t, a, b
bz      t

a <= b and branch
clte    t, a, b
bz      t

a >= b and branch
slt     t, a, b
bz      t

a == b and branch
ceq     t, a, b
bz      t

a != b and branch
seq     t, a, b
bz      t

test for negative
clt     a, #0

64bit add   c = a + b
add     cl, al, bl
slt     t,  cl, al
add     ch, ah, bh
add     ch, ch, t

ideas:
use expansion space to set up li <reg>,#imm for common values
0
0xffffffff
8
16
24
0x0000ff00
0x00ff0000
0xff000000
some sort of fancy 'set bit x' kind of thing?
